using System.Reflection;
using System.Reflection.Metadata;
using Verse.Core;
using Verse.ECS;
using Verse.ECS.Scheduling.Configs;

namespace Verse.Core;

/// <summary>
/// A system that will have its wiring generated by <see cref="PolyECS.Generator"/>. Deriving classes must be
/// partial and have a method named Run with any parameters that are needed.
///
/// The rules for parameter resolution are
/// <list type="number">
/// <item> If there is a method annotated with [ParamProvider(paramName)] that returns a type that is assignable to the parameter, that will be used. </item>
/// <item> If the type implements IIntoSystemParam<TSelf>, the implementation will be used.</item>
/// <item> If no other rules match, it will be treated as a ResMut or a Res if the param is annotated with in. If the type is annotated as Nullable, It will be treated as an optional res.</item>
/// </list>
/// </summary>
public class ScheduleAttribute(string? schedule = null) : Attribute
{
	public App Schedule(App app, IIntoSystemConfigs system, params Attribute[] attributes)
	{
		system = SystemConfigAttribute.ApplyAll(system, attributes);
		return schedule != null ? app.AddSystems(schedule, system) : app.AddSystems(system);
	}

	public static App ScheduleFromAttributes(App app, IIntoSystemConfigs system, params Attribute[] attributes)
	{
		foreach (var attr in attributes) {
			if (attr is ScheduleAttribute systemAttr) {
				return systemAttr.Schedule(app, system, attributes);
			}
		}
		throw new Exception("No ScheduleAttribute found");
	}

	public static App ScheduleFromMethod(App app, IIntoSystemConfigs system, MethodInfo method)
	{
		var attrs = GetCustomAttributes(method);
		return ScheduleFromAttributes(app, system, attrs);
	}
}